import { __awaiter } from 'tslib';
import { createCommand, parseGlobalArgs, ensureAbsolute } from '@graphql-inspector/commands';
import { Logger, chalk, figures } from '@graphql-inspector/logger';
import { similar, getTypePrefix } from '@graphql-inspector/core';
import { extname } from 'path';
import { writeFileSync } from 'fs';

function handler({ schema, writePath, type, threshold, }) {
    const shouldWrite = typeof writePath !== 'undefined';
    const similarMap = similar(schema, type, threshold);
    if (!Object.keys(similarMap).length) {
        Logger.info('No similar types found');
    }
    else {
        for (const typeName in similarMap) {
            if (similarMap.hasOwnProperty(typeName)) {
                const matches = similarMap[typeName];
                const prefix = getTypePrefix(schema.getType(typeName));
                const sourceType = chalk.bold(typeName);
                const name = matches.bestMatch.target.typeId;
                Logger.log('');
                Logger.log(`${prefix} ${sourceType}`);
                Logger.log(printResult(name, matches.bestMatch.rating));
                matches.ratings.forEach((match) => {
                    Logger.log(printResult(match.target.typeId, match.rating));
                });
            }
        }
        if (shouldWrite) {
            if (typeof writePath !== 'string') {
                throw new Error(`--write is not valid file path: ${writePath}`);
            }
            const absPath = ensureAbsolute(writePath);
            const ext = extname(absPath).replace('.', '').toLocaleLowerCase();
            let output = undefined;
            const results = transformMap(similarMap);
            if (ext === 'json') {
                output = outputJSON(results);
            }
            if (output) {
                writeFileSync(absPath, output, {
                    encoding: 'utf-8',
                });
                Logger.success(`Available at ${absPath}\n`);
            }
            else {
                throw new Error(`Extension ${ext} is not supported`);
            }
        }
    }
}
const index = createCommand((api) => {
    const { loaders } = api;
    return {
        command: 'similar <schema>',
        describe: 'Find similar types in a schema',
        builder(yargs) {
            return yargs
                .positional('schema', {
                describe: 'Point to a schema',
                type: 'string',
                demandOption: true,
            })
                .options({
                n: {
                    alias: 'name',
                    describe: 'Name of a type',
                    type: 'string',
                },
                t: {
                    alias: 'threshold',
                    describe: 'Threshold of similarity ratio',
                    type: 'number',
                },
                w: {
                    alias: 'write',
                    describe: 'Write a file with stats',
                    type: 'string',
                },
            });
        },
        handler(args) {
            return __awaiter(this, void 0, void 0, function* () {
                const { headers, token } = parseGlobalArgs(args);
                const writePath = args.write;
                const type = args.name;
                const threshold = args.threshold;
                const schema = yield loaders.loadSchema(args.schema, {
                    headers,
                    token,
                });
                return handler({ schema, writePath, type, threshold });
            });
        },
    };
});
function indent(line, space) {
    return line.padStart(line.length + space, ' ');
}
function transformMap(similarMap) {
    const results = {};
    for (const typename in similarMap) {
        if (similarMap.hasOwnProperty(typename)) {
            const result = similarMap[typename];
            results[typename] = [];
            if (result.bestMatch) {
                results[typename].push(trasformResult(result.bestMatch));
            }
            if (result.ratings) {
                results[typename].push(...result.ratings.map(trasformResult));
            }
        }
    }
    return results;
}
function trasformResult(record) {
    return {
        typename: record.target.typeId,
        rating: record.rating,
    };
}
function outputJSON(results) {
    return JSON.stringify(results);
}
function printResult(name, rating) {
    const percentage = chalk.grey(`(${formatRating(rating)}%)`);
    return indent(`${printScale(rating)} ${percentage} ${name}`, 0);
}
function printScale(ratio) {
    const percentage = Math.floor(ratio * 100);
    const levels = [0, 30, 50, 70, 90];
    return levels
        .map((level) => percentage >= level)
        .map((enabled) => (enabled ? figures.bullet : chalk.gray(figures.bullet)))
        .join('');
}
function formatRating(ratio) {
    return Math.floor(ratio * 100);
}

export default index;
export { handler };
//# sourceMappingURL=index.esm.js.map
