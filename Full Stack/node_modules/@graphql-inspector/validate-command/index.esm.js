import { __awaiter } from 'tslib';
import { createCommand, parseGlobalArgs } from '@graphql-inspector/commands';
import { Logger, chalk, bolderize } from '@graphql-inspector/logger';
import { validate } from '@graphql-inspector/core';
import { Source, print } from 'graphql';

function handler({ schema, documents, strictFragments, maxDepth, apollo, keepClientFields, failOnDeprecated, }) {
    const invalidDocuments = validate(schema, documents.map((doc) => new Source(print(doc.document), doc.location)), {
        strictFragments,
        maxDepth,
        apollo,
        keepClientFields,
    });
    if (!invalidDocuments.length) {
        Logger.success('All documents are valid');
    }
    else {
        const errorsCount = countErrors(invalidDocuments);
        const deprecated = countDeprecated(invalidDocuments);
        if (errorsCount) {
            Logger.log(`\nDetected ${errorsCount} invalid document${errorsCount > 1 ? 's' : ''}:\n`);
            invalidDocuments.forEach((doc) => {
                if (doc.errors.length) {
                    renderInvalidDocument(doc).forEach((line) => {
                        Logger.log(line);
                    });
                }
            });
        }
        else if (!failOnDeprecated) {
            Logger.success('All documents are valid');
        }
        if (deprecated) {
            Logger.info(`\nDetected ${deprecated} document${deprecated > 1 ? 's' : ''} with deprecated fields:\n`);
            invalidDocuments.forEach((doc) => {
                if (doc.deprecated.length) {
                    renderDeprecatedUsageInDocument(doc, failOnDeprecated).forEach((line) => {
                        Logger.log(line);
                    });
                }
            });
        }
        if (errorsCount || (deprecated && failOnDeprecated)) {
            process.exit(1);
        }
    }
}
const index = createCommand((api) => {
    const { loaders } = api;
    return {
        command: 'validate <documents> <schema>',
        describe: 'Validate Fragments and Operations',
        builder(yargs) {
            return yargs
                .positional('schema', {
                describe: 'Point to a schema',
                type: 'string',
                demandOption: true,
            })
                .positional('documents', {
                describe: 'Point to docuents',
                type: 'string',
                demandOption: true,
            })
                .options({
                deprecated: {
                    alias: 'd',
                    describe: 'Fail on deprecated usage',
                    type: 'boolean',
                    default: false,
                },
                noStrictFragments: {
                    describe: 'Do not fail on duplicated fragment names',
                    type: 'boolean',
                    default: false,
                },
                maxDepth: {
                    describe: 'Fail on deep operations',
                    type: 'number',
                },
                apollo: {
                    describe: 'Support Apollo directives',
                    type: 'boolean',
                    default: false,
                },
                keepClientFields: {
                    describe: 'Keeps the fields with @client, but removes @client directive from them',
                    type: 'boolean',
                    default: false,
                },
            });
        },
        handler(args) {
            return __awaiter(this, void 0, void 0, function* () {
                const { headers, token } = parseGlobalArgs(args);
                const apollo = args.apollo || false;
                const maxDepth = args.maxDepth || undefined;
                const strictFragments = !args.noStrictFragments;
                const keepClientFields = args.keepClientFields || false;
                const failOnDeprecated = args.deprecated;
                const schema = yield loaders.loadSchema(args.schema, {
                    headers,
                    token,
                });
                const documents = yield loaders.loadDocuments(args.documents);
                return handler({
                    schema,
                    documents,
                    apollo,
                    maxDepth,
                    strictFragments,
                    keepClientFields,
                    failOnDeprecated,
                });
            });
        },
    };
});
function countErrors(invalidDocuments) {
    if (invalidDocuments.length) {
        return invalidDocuments.filter((doc) => doc.errors && doc.errors.length)
            .length;
    }
    return 0;
}
function countDeprecated(invalidDocuments) {
    if (invalidDocuments.length) {
        return invalidDocuments.filter((doc) => doc.deprecated && doc.deprecated.length).length;
    }
    return 0;
}
function renderInvalidDocument(invalidDoc) {
    const errors = invalidDoc.errors
        .map((e) => ` - ${bolderize(e.message)}`)
        .join('\n');
    return [
        chalk.redBright('error'),
        `in ${invalidDoc.source.name}:\n\n`,
        errors,
        '\n\n',
    ];
}
function renderDeprecatedUsageInDocument(invalidDoc, isCritical = false) {
    const deprecated = invalidDoc.deprecated
        .map((e) => ` - ${bolderize(e.message)}`)
        .join('\n');
    return [
        isCritical ? chalk.redBright('error') : chalk.yellowBright('warn'),
        `in ${invalidDoc.source.name}:\n\n`,
        deprecated,
        '\n\n',
    ];
}

export default index;
export { handler };
//# sourceMappingURL=index.esm.js.map
