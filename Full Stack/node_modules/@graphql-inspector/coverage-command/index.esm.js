import { __awaiter } from 'tslib';
import { createCommand, parseGlobalArgs, ensureAbsolute } from '@graphql-inspector/commands';
import { Logger, chalk } from '@graphql-inspector/logger';
import { coverage, getTypePrefix } from '@graphql-inspector/core';
import { Source, print } from 'graphql';
import { extname } from 'path';
import { writeFileSync } from 'fs';

function handler({ schema, documents, silent, writePath, }) {
    const shouldWrite = typeof writePath !== 'undefined';
    const coverage$1 = coverage(schema, documents.map((doc) => new Source(print(doc.document), doc.location)));
    if (silent !== true) {
        renderCoverage(coverage$1);
    }
    if (shouldWrite) {
        if (typeof writePath !== 'string') {
            throw new Error(`--write is not valid file path: ${writePath}`);
        }
        const absPath = ensureAbsolute(writePath);
        const ext = extname(absPath).replace('.', '').toLocaleLowerCase();
        let output = undefined;
        if (ext === 'json') {
            output = outputJSON(coverage$1);
        }
        if (output) {
            writeFileSync(absPath, output, {
                encoding: 'utf-8',
            });
            Logger.success(`Available at ${absPath}\n`);
        }
        else {
            throw new Error(`Extension ${ext} is not supported`);
        }
    }
}
const index = createCommand((api) => {
    const { loaders } = api;
    return {
        command: 'coverage <documents> <schema>',
        describe: 'Schema coverage based on documents',
        builder(yargs) {
            return yargs
                .positional('schema', {
                describe: 'Point to a schema',
                type: 'string',
                demandOption: true,
            })
                .positional('documents', {
                describe: 'Point to documents',
                type: 'string',
                demandOption: true,
            })
                .options({
                w: {
                    alias: 'write',
                    describe: 'Write a file with coverage stats',
                    type: 'string',
                },
                s: {
                    alias: 'silent',
                    describe: 'Do not render any stats in the terminal',
                    type: 'boolean',
                },
            });
        },
        handler(args) {
            return __awaiter(this, void 0, void 0, function* () {
                const writePath = args.write;
                const silent = args.silent;
                const { headers, token } = parseGlobalArgs(args);
                const schema = yield loaders.loadSchema(args.schema, {
                    token,
                    headers,
                });
                const documents = yield loaders.loadDocuments(args.documents);
                return handler({ schema, documents, silent, writePath });
            });
        },
    };
});
function outputJSON(coverage) {
    return JSON.stringify(coverage, null, 2);
}
function renderCoverage(coverage) {
    Logger.info('Schema coverage based on documents:\n');
    for (const typeName in coverage.types) {
        if (coverage.types.hasOwnProperty(typeName)) {
            const typeCoverage = coverage.types[typeName];
            Logger.log([
                chalk.grey(getTypePrefix(typeCoverage.type)),
                chalk.bold(`${typeName}`),
                chalk.grey('{'),
            ].join(' '));
            for (const childName in typeCoverage.children) {
                if (typeCoverage.children.hasOwnProperty(childName)) {
                    const childCoverage = typeCoverage.children[childName];
                    if (childCoverage.hits) {
                        Logger.log([
                            indent(childName, 2),
                            chalk.italic.grey(`x ${childCoverage.hits}`),
                        ].join(' '));
                    }
                    else {
                        Logger.log([
                            chalk.redBright(indent(childName, 2)),
                            chalk.italic.grey('x 0'),
                        ].join(' '));
                    }
                }
            }
            Logger.log(chalk.grey('}\n'));
        }
    }
}
function indent(line, space) {
    return line.padStart(line.length + space, ' ');
}

export default index;
export { handler };
//# sourceMappingURL=index.esm.js.map
