'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const tslib = require('tslib');
const commands = require('@graphql-inspector/commands');
const logger = require('@graphql-inspector/logger');
const core = require('@graphql-inspector/core');
const graphql = require('graphql');
const path = require('path');
const fs = require('fs');

function handler({ schema, documents, silent, writePath, }) {
    const shouldWrite = typeof writePath !== 'undefined';
    const coverage = core.coverage(schema, documents.map((doc) => new graphql.Source(graphql.print(doc.document), doc.location)));
    if (silent !== true) {
        renderCoverage(coverage);
    }
    if (shouldWrite) {
        if (typeof writePath !== 'string') {
            throw new Error(`--write is not valid file path: ${writePath}`);
        }
        const absPath = commands.ensureAbsolute(writePath);
        const ext = path.extname(absPath).replace('.', '').toLocaleLowerCase();
        let output = undefined;
        if (ext === 'json') {
            output = outputJSON(coverage);
        }
        if (output) {
            fs.writeFileSync(absPath, output, {
                encoding: 'utf-8',
            });
            logger.Logger.success(`Available at ${absPath}\n`);
        }
        else {
            throw new Error(`Extension ${ext} is not supported`);
        }
    }
}
const index = commands.createCommand((api) => {
    const { loaders } = api;
    return {
        command: 'coverage <documents> <schema>',
        describe: 'Schema coverage based on documents',
        builder(yargs) {
            return yargs
                .positional('schema', {
                describe: 'Point to a schema',
                type: 'string',
                demandOption: true,
            })
                .positional('documents', {
                describe: 'Point to documents',
                type: 'string',
                demandOption: true,
            })
                .options({
                w: {
                    alias: 'write',
                    describe: 'Write a file with coverage stats',
                    type: 'string',
                },
                s: {
                    alias: 'silent',
                    describe: 'Do not render any stats in the terminal',
                    type: 'boolean',
                },
            });
        },
        handler(args) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const writePath = args.write;
                const silent = args.silent;
                const { headers, token } = commands.parseGlobalArgs(args);
                const schema = yield loaders.loadSchema(args.schema, {
                    token,
                    headers,
                });
                const documents = yield loaders.loadDocuments(args.documents);
                return handler({ schema, documents, silent, writePath });
            });
        },
    };
});
function outputJSON(coverage) {
    return JSON.stringify(coverage, null, 2);
}
function renderCoverage(coverage) {
    logger.Logger.info('Schema coverage based on documents:\n');
    for (const typeName in coverage.types) {
        if (coverage.types.hasOwnProperty(typeName)) {
            const typeCoverage = coverage.types[typeName];
            logger.Logger.log([
                logger.chalk.grey(core.getTypePrefix(typeCoverage.type)),
                logger.chalk.bold(`${typeName}`),
                logger.chalk.grey('{'),
            ].join(' '));
            for (const childName in typeCoverage.children) {
                if (typeCoverage.children.hasOwnProperty(childName)) {
                    const childCoverage = typeCoverage.children[childName];
                    if (childCoverage.hits) {
                        logger.Logger.log([
                            indent(childName, 2),
                            logger.chalk.italic.grey(`x ${childCoverage.hits}`),
                        ].join(' '));
                    }
                    else {
                        logger.Logger.log([
                            logger.chalk.redBright(indent(childName, 2)),
                            logger.chalk.italic.grey('x 0'),
                        ].join(' '));
                    }
                }
            }
            logger.Logger.log(logger.chalk.grey('}\n'));
        }
    }
}
function indent(line, space) {
    return line.padStart(line.length + space, ' ');
}

exports.default = index;
exports.handler = handler;
//# sourceMappingURL=index.cjs.js.map
