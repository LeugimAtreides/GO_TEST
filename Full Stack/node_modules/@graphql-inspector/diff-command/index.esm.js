import { __awaiter } from 'tslib';
import { createCommand, parseGlobalArgs, ensureAbsolute } from '@graphql-inspector/commands';
import { Logger, symbols, bolderize } from '@graphql-inspector/logger';
import { diff, CriticalityLevel, DiffRule } from '@graphql-inspector/core';
import { existsSync } from 'fs';

function handler(input) {
    const onComplete = input.onComplete
        ? resolveCompletionHandler(input.onComplete)
        : failOnBreakingChanges;
    const rules = input.rules
        ? input.rules
            .filter(isString)
            .map((name) => {
            const rule = resolveRule(name);
            if (!rule) {
                throw new Error(`\Rule '${name}' does not exist!\n`);
            }
            return rule;
        })
            .filter((f) => f)
        : [];
    const changes = diff(input.oldSchema, input.newSchema, rules);
    if (changes.length === 0) {
        Logger.success('No changes detected');
        return;
    }
    Logger.log(`\nDetected the following changes (${changes.length}) between schemas:\n`);
    const breakingChanges = changes.filter((change) => change.criticality.level === CriticalityLevel.Breaking);
    const dangerousChanges = changes.filter((change) => change.criticality.level === CriticalityLevel.Dangerous);
    const nonBreakingChanges = changes.filter((change) => change.criticality.level === CriticalityLevel.NonBreaking);
    if (breakingChanges.length) {
        reportBreakingChanges(breakingChanges);
    }
    if (dangerousChanges.length) {
        reportDangerousChanges(dangerousChanges);
    }
    if (nonBreakingChanges.length) {
        reportNonBreakingChanges(nonBreakingChanges);
    }
    onComplete({ breakingChanges, dangerousChanges, nonBreakingChanges });
}
const index = createCommand((api) => {
    const { loaders } = api;
    return {
        command: 'diff <oldSchema> <newSchema>',
        describe: 'Compare two GraphQL Schemas',
        builder(yargs) {
            return yargs
                .positional('oldSchema', {
                describe: 'Point to an old schema',
                type: 'string',
                demandOption: true,
            })
                .positional('newSchema', {
                describe: 'Point to a new schema',
                type: 'string',
                demandOption: true,
            })
                .options({
                rule: {
                    describe: 'Add rules',
                    array: true,
                },
                onComplete: {
                    describe: 'Handle Completion',
                    type: 'string',
                },
            });
        },
        handler(args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const oldSchemaPointer = args.oldSchema;
                    const newSchemaPointer = args.newSchema;
                    const { headers, token } = parseGlobalArgs(args);
                    const oldSchema = yield loaders.loadSchema(oldSchemaPointer, {
                        headers,
                        token,
                    });
                    const newSchema = yield loaders.loadSchema(newSchemaPointer, {
                        headers,
                        token,
                    });
                    handler({
                        oldSchema,
                        newSchema,
                        rules: args.rule,
                        onComplete: args.onComplete,
                    });
                }
                catch (error) {
                    Logger.error(error);
                    throw error;
                }
            });
        },
    };
});
function sortChanges(changes) {
    return changes.slice().sort((a, b) => {
        const aPath = a.path || '';
        const bPath = b.path || '';
        if (aPath > bPath) {
            return 1;
        }
        if (bPath > aPath) {
            return -1;
        }
        return 0;
    });
}
function reportBreakingChanges(changes) {
    const label = symbols.error;
    const sorted = sortChanges(changes);
    sorted.forEach((change) => {
        Logger.log(`${label}  ${bolderize(change.message)}`);
    });
}
function reportDangerousChanges(changes) {
    const label = symbols.warning;
    const sorted = sortChanges(changes);
    sorted.forEach((change) => {
        Logger.log(`${label}  ${bolderize(change.message)}`);
    });
}
function reportNonBreakingChanges(changes) {
    const label = symbols.success;
    const sorted = sortChanges(changes);
    sorted.forEach((change) => {
        Logger.log(`${label}  ${bolderize(change.message)}`);
    });
}
function resolveRule(name) {
    const filepath = ensureAbsolute(name);
    if (existsSync(filepath)) {
        return require(filepath);
    }
    return DiffRule[name];
}
function resolveCompletionHandler(name) {
    const filepath = ensureAbsolute(name);
    try {
        require.resolve(filepath);
    }
    catch (error) {
        throw new Error(`CompletionHandler '${name}' does not exist!`);
    }
    const mod = require(filepath);
    return (mod === null || mod === void 0 ? void 0 : mod.default) || mod;
}
function failOnBreakingChanges({ breakingChanges }) {
    const breakingCount = breakingChanges.length;
    if (breakingCount) {
        Logger.error(`Detected ${breakingCount} breaking change${breakingCount > 1 ? 's' : ''}`);
        process.exit(1);
    }
    else {
        Logger.success('No breaking changes detected');
    }
}
function isString(val) {
    return typeof val === 'string';
}

export default index;
export { handler };
//# sourceMappingURL=index.esm.js.map
